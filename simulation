library(Matrix);
library(glmnet);
library(expm);
library(flare);
setwd("/home/zzym/rrr/sslasso_code")
source("lasso_inference.r");
library(MASS)



#Skim SSlasso#
SSLasso_skim <- function (X, y, alpha=0.05, lambda = NULL, mu = NULL, intercept = TRUE, 
                          resol=1.3, maxiter=50, threshold=1e-2, verbose = TRUE) {
  #
  # Compute confidence intervals and p-values.
  #
  # Args:
  #   X     :  design matrix
  #   y     :  response
  #   alpha :  significance level
  #   lambda:  Lasso regularization parameter (if null, fixed by sqrt lasso)
  #   mu    :  Linfty constraint on M (if null, searches)
  #   resol :  step parameter for the function that computes M
  #   maxiter: iteration parameter for computing M
  #   threshold : tolerance criterion for computing M
  #   verbose : verbose?
  #
  # Returns:
  #   noise.sd: Estimate of the noise standard deviation
  #   norm0   : Estimate of the number of 'significant' coefficients
  #   coef    : Lasso estimated coefficients
  #   unb.coef: Unbiased coefficient estimates
  #   low.lim : Lower limits of confidence intervals
  #   up.lim  : upper limit of confidence intervals
  #   pvals   : p-values for the coefficients						 
  #
  p <- ncol(X);
  n <- nrow(X);
  pp <- p;
  col.norm <- 1/sqrt((1/n)*diag(t(X)%*%X));
  X <- X %*% diag(col.norm);
  
  htheta <- Lasso_skim (X,y,lambda=lambda,intercept=intercept);
  
  if (intercept==TRUE){
    Xb <- cbind(rep(1,n),X);
    col.norm <- c(1,col.norm);
    pp <- (p+1);
  } else {
    Xb <- X;
  }
  sigma.hat <- (1/n)*(t(Xb)%*%Xb);
  
  if ((n>=2*p)){
    tmp <- eigen(sigma.hat)
    tmp <- min(tmp$values)/max(tmp$values)
  }else{
    tmp <- 0
  }
  
  if ((n>=2*p)&&(tmp>=1e-4)){
    M <- solve(sigma.hat)
  }else{
    M <- InverseLinfty(sigma.hat, n, resol=resol, mu=mu, maxiter=maxiter, threshold=threshold, verbose=verbose);
  }
  
  unbiased.Lasso <- as.numeric(htheta + (M%*%t(Xb)%*%(y - Xb %*% htheta))/n);
  
  A <- M %*% sigma.hat %*% t(M);
  noise <- NoiseSd( unbiased.Lasso, A, n );
  s.hat <- noise$sd;
  
  #interval.sizes <- qnorm(1-(alpha/2))*s.hat*sqrt(diag(A))/(sqrt(n));
  
  if  (is.null(lambda)){
    lambda <- s.hat*sqrt(qnorm(1-(0.1/p))/n);
  }
  
  #addlength <- rep(0,pp);
  #MM <- M%*%sigma.hat - diag(pp);
  #for (i in 1:pp){
  #effectivemuvec <- sort(abs(MM[i,]),decreasing=TRUE);
  #effectivemuvec <- effectivemuvec[0:(noise$nz-1)];
  #addlength[i] <- sqrt(sum(effectivemuvec*effectivemuvec))*lambda;
  #}  
  
  htheta <- htheta*col.norm;
  unbiased.Lasso <- unbiased.Lasso*col.norm;
  
  if (intercept==TRUE){
    htheta <- htheta[2:pp];
    unbiased.Lasso <- unbiased.Lasso[2:pp];
  }  
  p.vals <- 2*(1-pnorm(sqrt(n)*abs(unbiased.Lasso)/(s.hat*col.norm[(pp-p+1):pp]*sqrt(diag(A[(pp-p+1):pp,(pp-p+1):pp])))))
  
  returnList <- list(
    "coef" = htheta,
    "pvals" = p.vals
  )
  return(returnList)
}

#simulation start#

p=2200
n=200
b1 <- c(5,rep(5/sqrt(10),10),-5,rep(-5/sqrt(10),10),3,rep(3/sqrt(10),10),-3,rep(-3/sqrt(10),10),rep(0,p-44))
b2 <- c(5,rep(-5/sqrt(10),3),rep(5/sqrt(10),7),-5,rep(5/sqrt(10),3),rep(-5/sqrt(10),7),3,rep(-3/sqrt(10),3),rep(3/sqrt(10),7),-3,rep(3/sqrt(10),3),rep(-3/sqrt(10),7),rep(0,p-44))
b3 <- c(5,rep(5/10,10),-5,rep(-5/10,10),3,rep(3/10,10),-3,rep(-3/10,10),rep(0,p-44))
b4 <- c(5,rep(-5/10,3),rep(5/10,7),-5,rep(5/10,3),rep(-5/10,7),3,rep(-3/10,3),rep(3/10,7),-3,rep(3/10,3),rep(-3/10,7),rep(0,p-44))


#simulation function#
simulation <- function(result,b,datanum){
for(q in 1:50){
  set.seed(q)
e <-rnorm(n,mean = 0,sd=(sum(b^2))/4)
gene <- vector()
Xtf <- matrix(rep(0,n*200),ncol=200)
X <- matrix(nrow=n,ncol=p)
for (i in 1:n) {
  Xtf[i,] <- rnorm(200)
  for(j in 1:200){
    gene <- rnorm(n=10,mean=0.7*Xtf[i,j],0.51)
    X[i,((j-1)*10+j):(j*10+j)] <- c(Xtf[i,j],gene)
  }
}
Y <- vector()
for (i in 1:n) {
  Y[i] <- X[i,]%*%b+e[i]
}
assign(paste("Data",datanum,"_",q,sep=""),data.frame(Y,X))
th <- SSLasso(X,Y,verbose = TRUE)
f <- cbind(th$coef,th$pvals)
result <- cbind(result,f)
result <- as.data.frame(result)
}
  #colname the result#
    betaseq<- seq(from=1,to=100,by=2)
    l=1
    for (i in betaseq) {
      colnames(result)[i] <- paste("Data",datanum,"_",l,"_beta",sep="")  
      l=l+1
    }
    pvalseq <- seq(from=2,to=100,by=2)
    p=1
    for (i in pvalseq) {
      colnames(result)[i] <- paste("Data",datanum,"_",p,"_pvals",sep ="")  
      p=p+1  
    }
}


#find out the file path#
getwd()
#generate Data1 with 50 seeds
result1 <-vector()
simulation(result1,b1,1)
#export the data#
write.csv(reult1,file="Simulation Data1.csv")






